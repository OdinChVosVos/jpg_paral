## Лицензии

Данный проект использует следующие библиотеки с открытым кодом:

### pybind11
Python биндинги реализованы с использованием pybind11.
- Лицензия: BSD-3-Clause
- Copyright (c) 2016 Wenzel Jakob
- Полный текст лицензии: [LICENSE_PYBIND11](LICENSE_PYBIND11)
- Репозиторий: https://github.com/pybind/pybind11

## Описание кода

### CMakeLists.txt

Конфигурационный файл CMake для автоматизации сборки проекта. Устанавливает стандарт C++17, включает флаги оптимизации компилятора `-O3` и `-march=native` для максимальной производительности на целевой архитектуре. Подключает библиотеку OpenMP для параллельного программирования и создает статическую библиотеку `jpeg_lib` из исходных файлов в директории `src/`, а также исполняемый файл `jpeg_test` для тестирования.

### include/dct.h и src/dct.cpp

Реализация дискретного косинусного преобразования (DCT) — ключевого компонента JPEG-сжатия. Класс `DCT` предоставляет методы прямого и обратного DCT для блоков 8×8 пикселей. Функция `forward_dct` реализует стандартную формулу двумерного DCT, вычисляя коэффициенты преобразования через двойной цикл по входным данным. Метод `forward_dct_optimized` использует предвычисленную таблицу косинусных значений (`cosine_table`), что существенно сокращает количество вызовов функции `cos()` и повышает производительность. Функция `inverse_dct` выполняет обратное преобразование для восстановления пространственных данных из частотной области. Вспомогательная функция `C(u)` возвращает нормализующий коэффициент, равный $\frac{1}{\sqrt{2}}$ для нулевых частот и 1 для остальных.

### include/quantization.h и src/quantization.cpp

Модуль квантования DCT-коэффициентов — этап, вносящий основные потери при сжатии. Класс содержит две стандартные матрицы квантования JPEG: `LUMINANCE_QUANT_TABLE` для яркостной компоненты и `CHROMINANCE_QUANT_TABLE` для цветовых компонент. Метод `scale_quantization_table` адаптирует матрицу квантования в зависимости от параметра качества (1-100), используя нелинейную формулу масштабирования: для низкого качества (< 50) применяется формула `5000/quality`, для высокого — `200 - quality*2`. Функция `quantize` делит каждый DCT-коэффициент на соответствующее значение из масштабированной матрицы квантования и округляет результат до целого числа, что приводит к потере высокочастотных деталей. Метод `dequantize` выполняет обратную операцию умножением квантованных коэффициентов на значения матрицы.

### include/jpeg_encoder.h и src/jpeg_encoder.cpp

Главный класс-энкодер, координирующий весь процесс JPEG-сжатия с параллельной обработкой. Конструктор принимает параметры качества (по умолчанию 85) и количество потоков (по умолчанию 4), инициализируя OpenMP. Метод `rgb_to_ycbcr` конвертирует цветовое пространство RGB в YCbCr, применяя стандартные коэффициенты преобразования с использованием директивы `#pragma omp parallel for` для параллелизации. Функция `process_block` обрабатывает единичный блок 8×8: смещает значения пикселей на 128 (из диапазона  в [-128, 127]), применяет DCT, квантует результат и записывает в выходной массив. Метод `process_channel_parallel` разбивает целый канал изображения на блоки 8×8 и обрабатывает их параллельно директивой `#pragma omp parallel for schedule(dynamic)`, что обеспечивает динамическое распределение нагрузки между потоками. Главная функция `encode` использует `#pragma omp parallel sections` для одновременной обработки трех цветовых каналов (Y, Cb, Cr), измеряет время выполнения с помощью `omp_get_wtime()` и возвращает закодированные данные. Метод `ycbcr_to_rgb` выполняет обратное цветовое преобразование с применением параллелизма.

### test/test_encoder.cpp

Модуль тестирования и бенчмаркинга производительности библиотеки. Функция `generate_test_image` создает синтетическое изображение с градиентным паттерном для воспроизводимого тестирования. Функция `benchmark_threads` измеряет влияние количества потоков (1, 2, 4, 8) на время кодирования, используя `std::chrono::high_resolution_clock` для точных замеров производительности. Метод `benchmark_quality` оценивает зависимость времени сжатия и размера выходных данных от параметра качества (10, 30, 50, 75, 95). Главная функция `main` запускает батарею тестов на изображениях различных размеров (от 512×512 до 4096×4096 пикселей), выводя результаты в консоль для анализа масштабируемости и эффективности параллелизации.

Реализация демонстрирует ключевые техники оптимизации: предвычисление косинусных таблиц, динамическое планирование задач OpenMP, секционирование параллельных регионов для обработки независимых каналов и использование агрессивных флагов компиляции для максимальной производительности.


### Сборка проекта

**На Linux (Ubuntu/Fedora):**

```bash
# Установка зависимостей
sudo apt install build-essential cmake libomp-dev  # Ubuntu
sudo dnf install gcc-c++ cmake libomp-devel        # Fedora

# Клонирование или создание проекта
mkdir jpeg-parallel && cd jpeg-parallel
# ... скопировать все файлы в структуру проекта

# Сборка
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j$(nproc)

# Запуск тестов
./jpeg_test
```

**На Windows (с использованием WSL):**

```bash
# В WSL Ubuntu
cd /mnt/c/Users/YourName/projects/jpeg-parallel
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j$(nproc)
./jpeg_test
```


### Запуск и тестирование

Программа автоматически выполнит серию бенчмарков, тестируя производительность при различных конфигурациях:

```bash
./jpeg_test
```

Результаты покажут:

- Влияние количества потоков (1, 2, 4, 8) на время обработки
- Влияние уровня качества (10-95) на размер и время сжатия
- Время обработки для различных разрешений изображений


### Оптимизация производительности

**1. Настройка количества потоков:**

```cpp
JPEGEncoder encoder(85, omp_get_max_threads());  // Использовать все доступные ядра
```

**2. Настройка уровня качества:**

- Качество 10-30: максимальное сжатие, низкое качество
- Качество 50-75: баланс размера и качества
- Качество 85-95: высокое качество, минимальное сжатие